<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>探索数据之美</title>
  <icon>http://www.typedefine.cn/icon.png</icon>
  <subtitle>不忘初心，砥砺前行！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.typedefine.cn/"/>
  <updated>2020-03-13T06:46:04.000Z</updated>
  <id>http://www.typedefine.cn/</id>
  
  <author>
    <name>山野@成都</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka调研（3）：多点通信方案的设计-2</title>
    <link href="http://www.typedefine.cn/2020/03/13/%E5%88%A9%E7%94%A8Kafka%E8%AE%BE%E8%AE%A1%E5%BA%94%E7%94%A8%E5%B1%82%E5%A4%9A%E7%82%B9%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/"/>
    <id>http://www.typedefine.cn/2020/03/13/%E5%88%A9%E7%94%A8Kafka%E8%AE%BE%E8%AE%A1%E5%BA%94%E7%94%A8%E5%B1%82%E5%A4%9A%E7%82%B9%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/</id>
    <published>2020-03-13T06:46:04.000Z</published>
    <updated>2020-03-13T06:46:04.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-星形拓扑的通信模型&quot;&gt;&lt;a href=&quot;#1-星形拓扑的通信模型&quot; class=&quot;headerlink&quot; title=&quot;1. 星形拓扑的通信模型&quot;&gt;&lt;/a&gt;1. 星形拓扑的通信模型&lt;/h1&gt;&lt;p&gt;星形的意思是说，有一个消息接收和转发中心，应用两两之间并不直接通信。所有的应用层消息都通过Kafka集群进行中转。但是对Kafka来说，消息的机制是推拉机制。如果需要接收消息，需要应用层连接到集群，订阅感兴趣的topic，然后poll消息。&lt;/p&gt;
&lt;p&gt;为了实现这种模型，&lt;br&gt;&lt;strong&gt;1. 我们利用Kafka本身的ACL控制机制来对topic权限进行控制&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对每一个应用分配唯一的Consumer Group。&lt;/li&gt;
&lt;li&gt;对每一个接入的应用分配唯一的账户和密码。&lt;/li&gt;
&lt;li&gt;对每一个接入的应用分配SSL证书&lt;/li&gt;
&lt;li&gt;对每一个topic按照应用进行配置读写权限。&lt;/li&gt;
&lt;li&gt;对每一个接入的应用分配一个唯一的秘钥（该秘钥通过安全方式传递）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2. 同时我们在应用包装一层API进行消息分派机制&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层的消息需要进行加密。&lt;/li&gt;
&lt;li&gt;应用层需要校验消息的来源和完整性。&lt;/li&gt;
&lt;li&gt;判断该消息是否应该被处理，比如消息的接收方是否包含了自己。&lt;/li&gt;
&lt;li&gt;应用层需要按照消息的业务ID（或者其他机制）分派合适的处理函数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="http://www.typedefine.cn/categories/Kafka/"/>
    
      <category term="Architecture" scheme="http://www.typedefine.cn/categories/Kafka/Architecture/"/>
    
    
      <category term="Kafka" scheme="http://www.typedefine.cn/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://www.typedefine.cn/tags/Message-Queue/"/>
    
      <category term="Topo Comm model" scheme="http://www.typedefine.cn/tags/Topo-Comm-model/"/>
    
      <category term="Frameword" scheme="http://www.typedefine.cn/tags/Frameword/"/>
    
      <category term="星形拓扑通信" scheme="http://www.typedefine.cn/tags/%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91%E9%80%9A%E4%BF%A1/"/>
    
      <category term="应用层设计" scheme="http://www.typedefine.cn/tags/%E5%BA%94%E7%94%A8%E5%B1%82%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Kafka调研（3）：多点通信方案的设计-1</title>
    <link href="http://www.typedefine.cn/2020/02/17/Kafka%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A3%EF%BC%9A%E5%9F%BA%E4%BA%8EKafka%E5%A4%9A%E7%82%B9%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/"/>
    <id>http://www.typedefine.cn/2020/02/17/Kafka%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A3%EF%BC%9A%E5%9F%BA%E4%BA%8EKafka%E5%A4%9A%E7%82%B9%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/</id>
    <published>2020-02-17T03:30:38.000Z</published>
    <updated>2020-02-17T03:30:38.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/a&gt;1. 引言&lt;/h1&gt;&lt;p&gt;在华为核心网和无线领域有几个重量级的产品比如U2000/M2000等网管系统&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;http://ishare.iask.sina.com.cn/f/LmFNcBVsuz.html
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;。里面的底层通信就是一套基于MDP(Message Dispatching Process)的星形拓扑通信系统。不同的业务进程之间通过消息(REQ/RSP)来通信，而不是通信RPC或者库的依赖。&lt;/p&gt;
&lt;p&gt;由于年代久远，和现在主流的MQ技术相比有一些不同的地方，随便说几点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;消息序列化只支持ASN.1&lt;/em&gt;&lt;/strong&gt;. 当然好处在于提供一套抽象的语义定义，并且大家只需要传递ASN.1文件即可。或者由一个公共方将ASN.1文件编程对应的模型和支撑库提供给各个端对进行开发。但是同时呢，不好的地方也很明显，一方面是技术过时，再一个就是需要一个专门的团队来维护ASN.1定义和相应的工具；另一方面在于管理上没有形成一个好的ASN.1的分发机制。导致版本之间定义很混乱。对于前后向兼容性问题很难做到。当然，在网上也可以找到一些开源的ASN.1 Compiler&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;https://github.com/vlm/asn1c
&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;。能不能用不清楚。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;MDP并不支持消息的缓存和队列机制，本身也不提供可靠性保证。&lt;/em&gt;&lt;/strong&gt; 那么如何来提供不丢失的消息呢？ 在华为，答案是提供一个框架层，业务团队并不直接使用MDP提供的库和接口，而是使用封装之后的一套框架，这套框架中提供了可靠性事件的发送的。实现的机制就是在发送之前存库。在接收业务处理完成之后，再从数据库中移除。当然这套机制也出现过不少问题，比如消息积压，数据库的内容不断上涨，甚至在局点可能出现过数据库表过大，导致其他业务访问很慢，甚至于极端情况下，整个数据库崩掉的情况都有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;MDP无法水平扩展，当消息出现峰值的时候，MDP有可能出现丢包的问题。&lt;/em&gt;&lt;/strong&gt; 这个问题也比较头疼。这是从一开始设计的时候就没有考虑的问题。考虑到U2000/M2000对应的数据量实际上是很大的。假如MDP的处理峰值在于2000/s，每秒钟2W条消息尽力保证不丢包。 这个阈值总会在未来的某一天会被打破，那么这个时候问题就出来了，系统会出现频繁丢包，系统业务频繁故障，但是由于底层数据通道，在应用层面几乎无法做到一个比较好的解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;MDP采用ACE&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;http://www.dre.vanderbilt.edu/~schmidt/TAO-overview.html
&quot;&gt;[4]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;，这一套框架比较复杂。&lt;/em&gt;&lt;/strong&gt;当然整体的U2000/M2000都是基于这个来开发，导致比较重型。&lt;br&gt;另外就是在U2000/M2000北向领域，采用了大量的ACE/TAO/Event Channel机制。灵活性不够。&lt;br&gt;&lt;strong&gt;&lt;em&gt;为什么说CORBA是一个很不好的技术，最终会被时代所抛弃? 可以看这篇论文&lt;/em&gt;&lt;/strong&gt;。&lt;a href=&quot;/2020/02/17/Kafka%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A3%EF%BC%9A%E5%9F%BA%E4%BA%8EKafka%E5%A4%9A%E7%82%B9%E9%80%9A%E4%BF%A1%E6%96%B9%E6%A1%88/1142031.1142044.pdf&quot; title=&quot;下载链接&quot;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;当前通信架构转异构通信架构的难度。&lt;/em&gt;&lt;/strong&gt;对于U2000/M2000来说，所有的开发支撑库都需要自己来完成。当然，对于华为来说，这个不是问题。问题这是人力预算的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面说的一些问题在华为内部看来，有一些并不是问题，有一些问题可以绕过。有几个点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;客户的OSS/BSS系统都是基于CORBA调用。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;ITU的标准定义就是基于ASN.1模型发布。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;整个产品技术切换的成本太高, 所以要保护既有投资，CORBA技术带来的复杂度也可以成为一种护城河。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;整个业务开发团队转型所面临的学习成本、人才招聘、人力缺口等等。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，从这几点来考虑，保持当前技术稳定，保持客户服务的稳定变是重点。所以，对于大企业来说，真的不是某个技术好就要上的。上面这个并非是吐槽，而是纯粹从技术上来分析我所经历过的产品在架构上的一些问题。&lt;/p&gt;
&lt;p&gt;那么回过头来，那么如何通过messge queue来解耦不同系统（同构的还是异构的)来交换和通信来实现多异构同构系统之间的 星形通信呢？ 我们来做一个简单的设计。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="http://www.typedefine.cn/categories/Kafka/"/>
    
      <category term="Architecture" scheme="http://www.typedefine.cn/categories/Kafka/Architecture/"/>
    
    
      <category term="Kafka" scheme="http://www.typedefine.cn/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://www.typedefine.cn/tags/Message-Queue/"/>
    
      <category term="Topo Comm model" scheme="http://www.typedefine.cn/tags/Topo-Comm-model/"/>
    
  </entry>
  
  <entry>
    <title>使用Socket.io搭建WS服务并通过Nginx反向代理</title>
    <link href="http://www.typedefine.cn/2020/02/17/%E7%94%A8Nodejs%E5%92%8CNginx%E6%90%AD%E5%BB%BAWebsocket%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.typedefine.cn/2020/02/17/%E7%94%A8Nodejs%E5%92%8CNginx%E6%90%AD%E5%BB%BAWebsocket%E6%9C%8D%E5%8A%A1%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</id>
    <published>2020-02-17T01:46:21.000Z</published>
    <updated>2020-03-07T04:40:00.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Nodejs、Express、Socket-io、Nginx&quot;&gt;&lt;a href=&quot;#Nodejs、Express、Socket-io、Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nodejs、Express、Socket.io、Nginx&quot;&gt;&lt;/a&gt;Nodejs、Express、Socket.io、Nginx&lt;/h1&gt;&lt;p&gt;使用Express框架和Socket.io库将websocket搭建起来，并监听同一个端口，参考官方例子&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;https://socket.io/docs/#Using-with-Express
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;就可以，非常简单。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; app = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;express&#39;&lt;/span&gt;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; server = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;http&#39;&lt;/span&gt;).Server(app);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; io = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;socket.io&#39;&lt;/span&gt;)(server);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server.listen(&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// WARNING: app.listen(80) will NOT work here!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.get(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;req, res&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;res.sendFile(__dirname + &lt;span class=&quot;string&quot;&gt;&#39;/index.html&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;io.on(&lt;span class=&quot;string&quot;&gt;&#39;connection&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;socket&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;socket.emit(&lt;span class=&quot;string&quot;&gt;&#39;news&#39;&lt;/span&gt;, &amp;#123; &lt;span class=&quot;attr&quot;&gt;hello&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;world&#39;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;socket.on(&lt;span class=&quot;string&quot;&gt;&#39;my other event&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;h1 id=&quot;Nginx同时作为Web-Server和WebSocket-Reverse-Proxy&quot;&gt;&lt;a href=&quot;#Nginx同时作为Web-Server和WebSocket-Reverse-Proxy&quot; class=&quot;headerlink&quot; title=&quot;Nginx同时作为Web Server和WebSocket Reverse Proxy&quot;&gt;&lt;/a&gt;Nginx同时作为Web Server和WebSocket Reverse Proxy&lt;/h1&gt;&lt;p&gt;在配置Nginx的时候，遇到了很多的问题，并且在网上现在找不到一篇对这个问题讲解的非常清楚的文档。&lt;br&gt;比如：&lt;/p&gt;
    
    </summary>
    
    
      <category term="websokcet" scheme="http://www.typedefine.cn/categories/websokcet/"/>
    
      <category term="nodejs" scheme="http://www.typedefine.cn/categories/websokcet/nodejs/"/>
    
    
      <category term="websocket" scheme="http://www.typedefine.cn/tags/websocket/"/>
    
      <category term="nginx" scheme="http://www.typedefine.cn/tags/nginx/"/>
    
      <category term="Socket.io" scheme="http://www.typedefine.cn/tags/Socket-io/"/>
    
      <category term="Nodejs" scheme="http://www.typedefine.cn/tags/Nodejs/"/>
    
      <category term="express" scheme="http://www.typedefine.cn/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Kafka调研（2）：消息序列化框架建议与对比</title>
    <link href="http://www.typedefine.cn/2020/02/14/Kafka%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A2-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6%E6%A8%AA%E5%90%91%E5%AF%B9%E6%AF%94/"/>
    <id>http://www.typedefine.cn/2020/02/14/Kafka%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A2-%E6%B6%88%E6%81%AF%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6%E6%A8%AA%E5%90%91%E5%AF%B9%E6%AF%94/</id>
    <published>2020-02-14T03:57:26.000Z</published>
    <updated>2020-02-14T03:57:26.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;调研结果和建议&quot;&gt;&lt;a href=&quot;#调研结果和建议&quot; class=&quot;headerlink&quot; title=&quot;调研结果和建议&quot;&gt;&lt;/a&gt;调研结果和建议&lt;/h2&gt;&lt;p&gt;综合来看，Avro或者Protocol Buffer二选一即可， 但是出于灵活性和标准JSON的支持力度上来看，更推荐Protocol Buffers。同时部分数据依然可以通过JSON方式传输。&lt;/p&gt;
&lt;h2 id=&quot;主流序列化框架对比&quot;&gt;&lt;a href=&quot;#主流序列化框架对比&quot; class=&quot;headerlink&quot; title=&quot;主流序列化框架对比&quot;&gt;&lt;/a&gt;主流序列化框架对比&lt;/h2&gt;&lt;h3 id=&quot;Kafka的序列化&quot;&gt;&lt;a href=&quot;#Kafka的序列化&quot; class=&quot;headerlink&quot; title=&quot;Kafka的序列化&quot;&gt;&lt;/a&gt;Kafka的序列化&lt;/h3&gt;&lt;p&gt;Kafka并不限定的消息格式。Kafka自身提供了一系列的序列化器，比如ByteArraySerializer，ByteBufferSerializer，DoubleSerializer，FloatSerializer，StringSerializer，UUIDSerializer， IntegerDeserializer, LongSerializer, ShortSerializer, 总结起来就是基本类型、字符串类型、二进制消息。&lt;/p&gt;
&lt;p&gt;但是在通常情况下不会使用比如Float这种来做序列化，原因在于系统间交互或者放到Kafka的数据一般来说都比较复杂，无法用一个字段来表示。于是，这种情况下，就需要在Kafka之上建立一个消息格式的契约，以便于Kafka的生产者和消费者之间都能理解消息中的语义。最好地方就是在Kafka基础之上增加一层应用层的消息协议，比如JSON格式、比如二进制编解码协议（序列化），出于性能考虑，一般也不直接使用Java POJO对象的原生序列化（虽然可行）。在Apache Spark中使用的Kryo Register，由于场景限制（不提供IDL定义），不适用Kafka。&lt;/p&gt;
&lt;p&gt;下面对常见的几个序列化框架做一个横向对比：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Message Queue - Kafka" scheme="http://www.typedefine.cn/categories/Message-Queue-Kafka/"/>
    
    
      <category term="Kafka" scheme="http://www.typedefine.cn/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://www.typedefine.cn/tags/Message-Queue/"/>
    
      <category term="Serialization" scheme="http://www.typedefine.cn/tags/Serialization/"/>
    
      <category term="JSON" scheme="http://www.typedefine.cn/tags/JSON/"/>
    
      <category term="Apahce Avro" scheme="http://www.typedefine.cn/tags/Apahce-Avro/"/>
    
      <category term="Apahce Thrift" scheme="http://www.typedefine.cn/tags/Apahce-Thrift/"/>
    
      <category term="Protocol Buffers" scheme="http://www.typedefine.cn/tags/Protocol-Buffers/"/>
    
      <category term="Architecture" scheme="http://www.typedefine.cn/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>Kafka调研（1）：跨数据中心的多集群镜像</title>
    <link href="http://www.typedefine.cn/2020/02/14/Kafka%E5%88%9D%E6%AD%A5%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A-%E8%B7%A8%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E9%9B%86%E7%BE%A4/"/>
    <id>http://www.typedefine.cn/2020/02/14/Kafka%E5%88%9D%E6%AD%A5%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A-%E8%B7%A8%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E9%9B%86%E7%BE%A4/</id>
    <published>2020-02-14T03:12:23.000Z</published>
    <updated>2020-02-14T03:12:23.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;调研结果和建议&quot;&gt;&lt;a href=&quot;#调研结果和建议&quot; class=&quot;headerlink&quot; title=&quot;调研结果和建议&quot;&gt;&lt;/a&gt;调研结果和建议&lt;/h2&gt;&lt;p&gt;针对是否可以跨数据中心部署Kafka集群的问题，答案是可行，但是不建议。建议先支持单集群部署，以简化运维成本，支持多地多应用业务上线。&lt;/p&gt;
&lt;h3 id=&quot;可行性与跨网络部署产生的问题&quot;&gt;&lt;a href=&quot;#可行性与跨网络部署产生的问题&quot; class=&quot;headerlink&quot; title=&quot;可行性与跨网络部署产生的问题&quot;&gt;&lt;/a&gt;可行性与跨网络部署产生的问题&lt;/h3&gt;&lt;p&gt;Kafka实际上并不禁止将Broker部署到不同的网络地域。但是，Kafka的设计是按照单个数据中心进行设计、开发、测试和调优的。从Kafka的官方文档&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Kafka Documentation#Datacenter。http://kafka.apache.org/documentation/#datacenters
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;来看，并不推荐将集群跨网络部署。 由于Broker分布在不同的跨地域的网络（WAN）, 除了数据同步会极大地增加延迟之外， 并且如果由于网络中断无法保证zk始终可用，带来其他问题，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Partition Leader无法选举。或者由于网络问题，某个Broker频繁掉线导致集群不稳定。&lt;/li&gt;
&lt;li&gt;在Producer推送数据时候，产生延迟（推送到remote Broker）。或者由于网络问题，无法获取ACK。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Message Queue - Kafka" scheme="http://www.typedefine.cn/categories/Message-Queue-Kafka/"/>
    
    
      <category term="Kafka" scheme="http://www.typedefine.cn/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://www.typedefine.cn/tags/Message-Queue/"/>
    
      <category term="Architecture" scheme="http://www.typedefine.cn/tags/Architecture/"/>
    
      <category term="Data center" scheme="http://www.typedefine.cn/tags/Data-center/"/>
    
      <category term="Cluster" scheme="http://www.typedefine.cn/tags/Cluster/"/>
    
      <category term="Mirror Maker" scheme="http://www.typedefine.cn/tags/Mirror-Maker/"/>
    
  </entry>
  
  <entry>
    <title>什么是Kafka</title>
    <link href="http://www.typedefine.cn/2020/02/14/%E4%BB%80%E4%B9%88%E6%98%AFKafka/"/>
    <id>http://www.typedefine.cn/2020/02/14/%E4%BB%80%E4%B9%88%E6%98%AFKafka/</id>
    <published>2020-02-14T02:30:23.000Z</published>
    <updated>2020-02-14T02:30:23.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;占坑，后面有时间对Kafka进行详细的更新&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;A-bit-of-History&quot;&gt;&lt;a href=&quot;#A-bit-of-History&quot; class=&quot;headerlink&quot; title=&quot;A bit of History&quot;&gt;&lt;/a&gt;A bit of History&lt;/h1&gt;&lt;p&gt;Kafka是高性能的、分布式的、数据可持久化的消息丢列。最初由LinkedIn开发，用来跟踪Web上的用户的一系列事件，譬如页面浏览(Page view)，搜索框的输入，展示的广告等等。这些事件对于监控和调查用于对于网站交互的参与度非常的重要。每天都有大量的数据产生，因为，需要一个可以轻松扩展，同时又不会增加额外负担的一个解决方案。&lt;/p&gt;
&lt;p&gt;总体来说，Kafka从设计之初有3个目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单的生产者/消费者API设计&lt;/li&gt;
&lt;li&gt;尽可能减少网络传输和磁盘存储的额外成本&lt;/li&gt;
&lt;li&gt;从一开始就为可扩展性而设计&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Message Queue - Kafka" scheme="http://www.typedefine.cn/categories/Message-Queue-Kafka/"/>
    
      <category term="Architecture" scheme="http://www.typedefine.cn/categories/Message-Queue-Kafka/Architecture/"/>
    
    
      <category term="Architecture" scheme="http://www.typedefine.cn/tags/Architecture/"/>
    
      <category term="Message Queue - Kafka" scheme="http://www.typedefine.cn/tags/Message-Queue-Kafka/"/>
    
      <category term="JMS" scheme="http://www.typedefine.cn/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>什么是MQ</title>
    <link href="http://www.typedefine.cn/2020/02/14/%E4%BB%80%E4%B9%88%E6%98%AFMQ/"/>
    <id>http://www.typedefine.cn/2020/02/14/%E4%BB%80%E4%B9%88%E6%98%AFMQ/</id>
    <published>2020-02-14T02:10:23.000Z</published>
    <updated>2020-02-14T02:10:23.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;这篇文章是一篇未完成稿，有时间再写&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是消息队列（Message-Queue）&quot;&gt;&lt;a href=&quot;#什么是消息队列（Message-Queue）&quot; class=&quot;headerlink&quot; title=&quot;什么是消息队列（Message Queue）?&quot;&gt;&lt;/a&gt;什么是消息队列（Message Queue）?&lt;/h1&gt;&lt;p&gt;消息队列使得应用之间可以通过互发消息的方式来通信，这和传统的RPC方式有很大的区别。通过消息队列提供的服务，解除了点对点，星形拓扑通信耦合的问题。同时，当目标服务不可用的时候，消息队列充当了临时的消息缓存。&lt;/p&gt;
&lt;p&gt;下面先解释一下什么是消息队列&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;https://www.cloudamqp.com/blog/2014-12-03-what-is-message-queuing.html
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;，怎么使用，在架构层面又会带来什么样的好处&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;扩展阅读：https://www.ibm.com/cloud/learn/message-queues
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;队列&lt;/em&gt;&lt;/strong&gt;就是将事物排成一列，依次处理，并且依照先进先出(First In, First Out)的顺序。那么消息队列（MQ），就是用于不同系统或者应用之间通信的的列表， 将需要通信的消息保存在队列中，等待应用依次处理。&lt;a href=&quot;http://queues.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;queues.io&lt;/a&gt;是一个比较好的网站可以查找各种不同功能的队列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Message Queue - Kafka" scheme="http://www.typedefine.cn/categories/Message-Queue-Kafka/"/>
    
    
      <category term="Message Queue" scheme="http://www.typedefine.cn/tags/Message-Queue/"/>
    
      <category term="Architecture" scheme="http://www.typedefine.cn/tags/Architecture/"/>
    
      <category term="JMS" scheme="http://www.typedefine.cn/tags/JMS/"/>
    
      <category term="AMQP" scheme="http://www.typedefine.cn/tags/AMQP/"/>
    
      <category term="MQTT" scheme="http://www.typedefine.cn/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>Thrift介绍、编译参数以及如何和maven集成</title>
    <link href="http://www.typedefine.cn/2020/02/13/thrift%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81%E5%8F%82%E6%95%B0/"/>
    <id>http://www.typedefine.cn/2020/02/13/thrift%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81%E5%8F%82%E6%95%B0/</id>
    <published>2020-02-13T13:07:49.000Z</published>
    <updated>2020-02-13T13:07:49.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Thrift&quot;&gt;&lt;a href=&quot;#什么是Thrift&quot; class=&quot;headerlink&quot; title=&quot;什么是Thrift?&quot;&gt;&lt;/a&gt;什么是Thrift?&lt;/h1&gt;&lt;p&gt;Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。它被当作一个远程过程调用（RPC）框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的跨平台高效服务，可以使用C#、C++（基于POSIX兼容系统）、Cappuccino、Cocoa、Delphi、Erlang、Go、Haskell、Java、Node.js、OCaml、Perl、PHP、Python、Ruby和Smalltalk。虽然它以前是由Facebook开发的，但它现在是Apache软件基金会的开源项目了。该实现被描述在2007年4月的一篇由Facebook发表的技术论文中，该论文现由Apache掌管。&lt;/p&gt;
&lt;p&gt;目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。本文将介绍由 Facebook 开发的远程服务调用框架 Apache Thrift，它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。本文将详细介绍 Thrift 的使用，并且提供丰富的实例代码加以解释说明，帮助使用者快速构建服务。Thrift的下载地址是：&lt;a href=&quot;http://thrift.apache.org/download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://thrift.apache.org/download&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;thrift-exe支持的参数有哪些？&quot;&gt;&lt;a href=&quot;#thrift-exe支持的参数有哪些？&quot; class=&quot;headerlink&quot; title=&quot;thrift.exe支持的参数有哪些？&quot;&gt;&lt;/a&gt;thrift.exe支持的参数有哪些？&lt;/h1&gt;
    
    </summary>
    
    
      <category term="thrift" scheme="http://www.typedefine.cn/categories/thrift/"/>
    
    
      <category term="thrift" scheme="http://www.typedefine.cn/tags/thrift/"/>
    
      <category term="compiler" scheme="http://www.typedefine.cn/tags/compiler/"/>
    
      <category term="command line options" scheme="http://www.typedefine.cn/tags/command-line-options/"/>
    
  </entry>
  
  <entry>
    <title>为什么会害怕人工智能</title>
    <link href="http://www.typedefine.cn/2020/02/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AE%B3%E6%80%95%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    <id>http://www.typedefine.cn/2020/02/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AE%B3%E6%80%95%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</id>
    <published>2020-02-12T03:08:30.000Z</published>
    <updated>2020-02-12T03:08:30.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;原作者： 保罗▪福特 2015年2月11日&lt;br&gt;译者： 山野@成都 2017&lt;/p&gt;
&lt;h1 id=&quot;在阅读之前&quot;&gt;&lt;a href=&quot;#在阅读之前&quot; class=&quot;headerlink&quot; title=&quot;在阅读之前&quot;&gt;&lt;/a&gt;在阅读之前&lt;/h1&gt;&lt;p&gt;这篇文章&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;https://www.technologyreview.com/s/534871/our-fear-of-artificial-intelligence/
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;是我在2017年在麻省理工评论（MIT Technology Review）上看到的翻译的。 作者是保罗▪福特&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;https://www.technologyreview.com/profile/paul-ford/
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;。距离当初的翻译已经过去了2年。现在人工智能的概念已经深入到各行各业，从大家经常接触的SNS社交数据挖掘、智能客服、B2C商品推荐系统、新闻推荐系统、智能汽车，以及到更广泛的更偏向于传统的领域，比如医疗、城市规划、交通领域、建筑领域、社区管理、行政服务等等的一切都在提到一个词，那就是“智慧”，“智能”。&lt;/p&gt;
&lt;p&gt;这一切的背后都和机器学习技术（深度学习、加强学习）等等的兴起，以及更加容易使用的框架和API，比如谷歌的tensorflow；更加容易处理大规模数据的框架，比如Apache Spark、Apache Hadoop套件等，这些都助力于并提高了各种业务对于基于大量数据的建模和预测能力。而这些能力就是大家所说的人工智能。&lt;/p&gt;
&lt;p&gt;下面这篇文章并没有讲解具体的某种应用于人工智能的技术，而是从更高更抽象的层面，从社会和伦理的层面探讨了人工智能所带来的一些问题。&lt;/p&gt;
&lt;p&gt;下面是正文：&lt;/p&gt;
    
    </summary>
    
    
      <category term="科技 - 人工智能" scheme="http://www.typedefine.cn/categories/%E7%A7%91%E6%8A%80-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="翻译" scheme="http://www.typedefine.cn/categories/%E7%A7%91%E6%8A%80-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="人工智能" scheme="http://www.typedefine.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="未来科技" scheme="http://www.typedefine.cn/tags/%E6%9C%AA%E6%9D%A5%E7%A7%91%E6%8A%80/"/>
    
      <category term="麻省理工评论" scheme="http://www.typedefine.cn/tags/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%E8%AF%84%E8%AE%BA/"/>
    
      <category term="自由意志" scheme="http://www.typedefine.cn/tags/%E8%87%AA%E7%94%B1%E6%84%8F%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>maven构建的一些小技巧</title>
    <link href="http://www.typedefine.cn/2020/02/10/maven%E6%9E%84%E5%BB%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.typedefine.cn/2020/02/10/maven%E6%9E%84%E5%BB%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-02-10T08:02:55.000Z</published>
    <updated>2020-02-10T08:02:55.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;maven从设计上来说非常的简单，但是却是一个非常强大的工具。很多人将maven只是当做一个构建工具（从源代码生成可运行软件），但是实际上可以将maven当做一个项目管理工具，比如工程管理、插件管理、Jar包依赖管理、软件发布仓库管理等。&lt;/p&gt;
&lt;p&gt;下面讲解一些在使用maven当中所遇到的一些小的技巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Building tools - maven" scheme="http://www.typedefine.cn/categories/Building-tools-maven/"/>
    
    
      <category term="maven" scheme="http://www.typedefine.cn/tags/maven/"/>
    
      <category term="profiles" scheme="http://www.typedefine.cn/tags/profiles/"/>
    
      <category term="settings.xml" scheme="http://www.typedefine.cn/tags/settings-xml/"/>
    
      <category term="mirrorOf" scheme="http://www.typedefine.cn/tags/mirrorOf/"/>
    
  </entry>
  
  <entry>
    <title>通过maven自动化构建protobuf class代码</title>
    <link href="http://www.typedefine.cn/2020/02/10/%E9%80%9A%E8%BF%87maven%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAprotobuf/"/>
    <id>http://www.typedefine.cn/2020/02/10/%E9%80%9A%E8%BF%87maven%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAprotobuf/</id>
    <published>2020-02-10T05:30:03.000Z</published>
    <updated>2020-02-10T05:30:03.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;通过maven自动化构建protocal-buffer&quot;&gt;&lt;a href=&quot;#通过maven自动化构建protocal-buffer&quot; class=&quot;headerlink&quot; title=&quot;通过maven自动化构建protocal buffer&quot;&gt;&lt;/a&gt;通过maven自动化构建protocal buffer&lt;/h2&gt;&lt;p&gt;当对代码进行工程构建的时候，如果能够尽可能的自动化，这样对于提升整个软件质量、节省人力成本、减少因为人工干预导致的各种不可预知的错误是很好。&lt;br&gt;从protobuf的官方文档来看，通过cmd调用protoc当然可以生成相应的代码，但是对构建不够友好。于是，可以考虑通过maven来进行自动化构建，在启动maven构建的时候，自动调用protoc，生成代码，并打包成相应的jar包，集成到工程发布包中。&lt;br&gt;这里有2种方式，如下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Building tools - maven" scheme="http://www.typedefine.cn/categories/Building-tools-maven/"/>
    
      <category term="protocol buffer" scheme="http://www.typedefine.cn/categories/Building-tools-maven/protocol-buffer/"/>
    
    
      <category term="maven" scheme="http://www.typedefine.cn/tags/maven/"/>
    
      <category term="protocol" scheme="http://www.typedefine.cn/tags/protocol/"/>
    
      <category term="buffer" scheme="http://www.typedefine.cn/tags/buffer/"/>
    
  </entry>
  
  <entry>
    <title>不同linux发行版软件安装工具</title>
    <link href="http://www.typedefine.cn/2020/02/09/%E4%B8%8D%E5%90%8Clinux%E5%8F%91%E8%A1%8C%E7%89%88%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.typedefine.cn/2020/02/09/%E4%B8%8D%E5%90%8Clinux%E5%8F%91%E8%A1%8C%E7%89%88%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7/</id>
    <published>2020-02-09T08:40:41.000Z</published>
    <updated>2020-02-09T08:40:41.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RPM&quot;&gt;&lt;a href=&quot;#RPM&quot; class=&quot;headerlink&quot; title=&quot;RPM&quot;&gt;&lt;/a&gt;RPM&lt;/h3&gt;&lt;p&gt;RPM是Red-Hat Package Manager（RPM软件包管理器）的缩写，这一文件格式名称虽然打上了RedHat的标志&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Redhat guide: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/deployment_guide/
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;，但是其原始设计理念是开放式的，现在包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。&lt;/p&gt;
&lt;h3 id=&quot;apt-get&quot;&gt;&lt;a href=&quot;#apt-get&quot; class=&quot;headerlink&quot; title=&quot;apt-get&quot;&gt;&lt;/a&gt;apt-get&lt;/h3&gt;&lt;p&gt;apt-get&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;RPM使用参考：https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/10/08/2203153.html
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;，是一条linux命令，适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。主要适用于Debian、Ubuntu的系统。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.typedefine.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.typedefine.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
